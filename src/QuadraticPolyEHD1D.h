#ifndef QuadraticPoly_EHD1D_H_\n#define QuadraticPoly_EHD1D_H_\n\n#include "./QuadraticPoly1D.h"\n\nnamespace PCMBaseCpp {\n\ntypedef SPLITT::OrderedTree<SPLITT::uint, LengthAndRegime> EHD1DTreeType;\n\ntemplate<class TreeType, class DataType>\nstruct CondGaussianEHD1D: public CondGaussianOmegaPhiV1D {\n  \n  TreeType const& ref_tree_;\n  \n  // number of regimes;\n  uint R_;\n  \n  bool transpose_Sigma_x = false;\n  \n  // EHD parameters for 1D case\n  std::vector<double> X0;\n  std::vector<double> rho;      // Early burst parameter\n  std::vector<double> H;        // Selection strength (scalar)\n  std::vector<double> Theta;    // Optimum value (scalar)\n  std::vector<double> Sigma_x;  // Variance parameter\n  std::vector<double> Sigmae_x; // Measurement error variance\n  \n  CondGaussianEHD1D(TreeType const& ref_tree, DataType const& ref_data, uint R): ref_tree_(ref_tree) {\n    this->R_ = R;\n    this->transpose_Sigma_x = ref_data.transpose_Sigma_x;\n  }\n  \n  CondGaussianEHD1D(TreeType const& ref_tree, DataType const& ref_data): ref_tree_(ref_tree) {\n    this->R_ = ref_data.R_;\n    this->transpose_Sigma_x = ref_data.transpose_Sigma_x;\n  }\n  \n  arma::uword SetParameter(std::vector<double> const& par, arma::uword offset) {\n    using namespace arma;\n    \n    uint npar = R_*(5);  // X0 + rho + H + Theta + Sigma_x + Sigmae_x\n    if(par.size() - offset < npar) {\n      std::ostringstream os;\n      os<<"QuadraticPolyEHD1D.h:CondEHD1D.SetParameter:: The length of the parameter vector minus offset ("<<par.size() - offset<<\n        ") should be at least of R*5, where "+\n          " R="<<R_<<" is the number of regimes.";\n      throw std::logic_error(os.str());\n    }\n    \n    X0.assign(R_, 0.0);\n    rho.assign(R_, 0.0);\n    H.assign(R_, 0.0);\n    Theta.assign(R_, 0.0);\n    Sigma_x.assign(R_, 0.0);\n    Sigmae_x.assign(R_, 0.0);\n    \n    for(uword r = 0; r < R_; r++) {\n      X0[r] = par[offset + r];\n      rho[r] = par[offset + R_ + r];\n      H[r] = par[offset + 2*R_ + r];\n      Theta[r] = par[offset + 3*R_ + r];\n      Sigma_x[r] = par[offset + 4*R_ + r];\n      Sigmae_x[r] = par[offset + 5*R_ + r];\n    }\n    \n    return npar;\n  }\n  \n  void CalculateOmegaPhiV(uint i, arma::uword ri, double& omega, double& phi, double& V) {\n    double t = this->ref_tree_.LengthOfBranch(i).length_;\n    \n    // Get node height for EB component (simplified for now)\n    double node_height = 0.0; // TODO: Implement proper node height calculation\n    \n    // Early Burst scaling factor\n    double eb_factor = (rho[ri] == 0.0) ? 1.0 : (1.0 - exp(-rho[ri] * node_height)) / rho[ri];\n    double sigma2 = Sigma_x[ri] * Sigma_x[ri] * eb_factor;\n    \n    if(std::abs(H[ri]) < 1e-8) {\n      // BM case with EB scaling\n      phi = 1.0;\n      omega = Theta[ri] * t;\n      V = sigma2 * t;\n    } else {\n      // OU case with EB scaling\n      double exp_Ht = exp(-H[ri] * t);\n      phi = exp_Ht;\n      omega = (1.0 - exp_Ht) * Theta[ri];\n      V = sigma2 * (1.0 - exp(-2.0 * H[ri] * t)) / (2.0 * H[ri]);\n    }\n    \n    // Add measurement error for tips\n    if(i < this->ref_tree_.num_tips()) {\n      V += Sigmae_x[ri] * Sigmae_x[ri];\n    }\n  }\n};\n\nclass EHD1D: public QuadraticPoly1D<EHD1DTreeType> {\npublic:  \n  typedef EHD1DTreeType TreeType;\n  typedef QuadraticPoly1D<TreeType> BaseType;\n  typedef EHD1D MyType;\n  typedef arma::vec StateType;\n  typedef NumericTraitData1D<TreeType::NodeType> DataType;\n  typedef std::vector<double> ParameterType;\n  typedef SPLITT::PostOrderTraversal<MyType> AlgorithmType;\n  \n  CondGaussianEHD1D<TreeType, DataType> cond_dist_;\n  \n  EHD1D(TreeType const& tree, DataType const& input_data):\n    BaseType(tree, input_data), cond_dist_(tree, input_data) {\n    BaseType::ptr_cond_dist_.push_back(&cond_dist_);\n  }\n  \n  void SetParameter(ParameterType const& par) {\n    cond_dist_.SetParameter(par, 0);\n  }\n};\n\ntypedef TraversalTaskWrapper<EHD1D> QuadraticPolyEHD1D;\n}  \n\n#endif // QuadraticPoly_EHD1D_H_\n