#ifndef QuadraticPoly_EHD_H_\n#define QuadraticPoly_EHD_H_\n\n#include "./QuadraticPoly.h"\n\nnamespace PCMBaseCpp {\n\ntypedef SPLITT::OrderedTree<SPLITT::uint, LengthAndRegime> EHDTreeType;\n\ntemplate<class TreeType, class DataType>\nstruct CondGaussianEHD: public CondGaussianOmegaPhiV {  \n  \n  TreeType const& ref_tree_;\n  \n  // number of traits\n  uint k_;\n  \n  // number of regimes;\n  uint R_;  \n  \n  bool transpose_Sigma_x = false;  \n  \n  // Each slice or column of the following cubes or matrices corresponds to one regime\n  arma::mat X0;\n  \n  // EHD parameters: combines EB (rho) and OU (H, Theta) parameters\n  arma::vec rho;        // Early burst parameter\n  arma::cube H;         // Selection strength matrix  \n  arma::mat Theta;      // Optimum values\n  arma::cube Sigma;\n  arma::cube Sigmae;\n  \n  // matrices of sums of pairs of eigenvalues lambda_i+lambda_j for each regime\n  arma::mat I;\n  \n  CondGaussianEHD(TreeType const& ref_tree, DataType const& ref_data, uint R): ref_tree_(ref_tree) {\n    this->k_ = ref_data.k_;\n    this->R_ = R;\n    this->I = arma::eye(k_, k_);\n    this->transpose_Sigma_x = ref_data.transpose_Sigma_x;\n  }\n  \n  CondGaussianEHD(TreeType const& ref_tree, DataType const& ref_data): ref_tree_(ref_tree) {\n    this->k_ = ref_data.k_;\n    this->R_ = ref_data.R_;\n    this->I = arma::eye(k_, k_);\n    this->transpose_Sigma_x = ref_data.transpose_Sigma_x;\n  }\n  \n  arma::uword SetParameter(std::vector<double> const& par, arma::uword offset) {\n    using namespace arma;\n    \n    uint npar = R_*(1 + k_*k_ + k_ + 2*k_*k_);  // rho + H + Theta + Sigma + Sigmae\n    if(par.size() - offset < npar) {\n      std::ostringstream os;\n      os<<"QuadraticPolyEHD.h:CondEHD.SetParameter:: The length of the parameter vector minus offset (")<<par.size() - offset<<\n        ") should be at least of R*(1+k^2+k+2k^2), where k="<<k_<<" is the number of traits and "<<\n          " R="<<R_<<" is the number of regimes.";\n      throw std::logic_error(os.str());\n    }\n    \n    X0 = mat(&par[offset], k_, R_);\n    rho = vec(&par[offset + k_*R_], R_);\n    H = cube(&par[offset + k_*R_ + R_], k_, k_, R_);\n    Theta = mat(&par[offset + k_*R_ + R_ + k_*k_*R_], k_, R_);\n    Sigma = cube(&par[offset + k_*R_ + R_ + k_*k_*R_ + k_*R_], k_, k_, R_);\n    Sigmae = cube(&par[offset + k_*R_ + R_ + k_*k_*R_ + k_*R_ + k_*k_*R_], k_, k_, R_);\n    \n    if(transpose_Sigma_x) {\n      for(uword r = 0; r < R_; r++) {\n        Sigma.slice(r) = Sigma.slice(r).t() * Sigma.slice(r);\n        Sigmae.slice(r) = Sigmae.slice(r).t() * Sigmae.slice(r);  \n      }\n    } else {\n      for(uword r = 0; r < R_; r++) {\n        Sigma.slice(r) = Sigma.slice(r) * Sigma.slice(r).t();\n        Sigmae.slice(r) = Sigmae.slice(r) * Sigmae.slice(r).t();  \n      }\n    }\n    return npar;\n  }\n  \n  void CalculateOmegaPhiV(uint i, arma::uword ri, arma::mat& omega, arma::cube& Phi, arma::cube& V) {\n    using namespace arma;\n    \n    double ti = this->ref_tree_.LengthOfBranch(i).length_;\n    \n    // Get node height for EB component\n    double node_height = 0.0; // TODO: Need to implement node height calculation\n    \n    // Early Burst component: time-dependent variance scaling\n    double eb_factor = (rho[ri] == 0.0) ? 1.0 : (1.0 - exp(-rho[ri] * node_height)) / rho[ri];\n    \n    // OU component matrices\n    mat H_regime = H.slice(ri);\n    vec theta_regime = Theta.col(ri);\n    mat Sigma_regime = Sigma.slice(ri) * eb_factor; // Apply EB scaling to variance\n    \n    // Calculate OU evolution matrices\n    mat exp_Ht;\n    if(arma::norm(H_regime, "fro") < 1e-8) {\n      // When H â‰ˆ 0, model reduces to BM with EB scaling\n      exp_Ht = I;\n      omega.col(i) = theta_regime * ti; // Linear drift toward optimum\n      \n      // BM-like variance with EB scaling\n      Phi.slice(i) = I;\n      V.slice(i) = Sigma_regime * ti;\n    } else {\n      // Full OU dynamics with EB scaling\n      exp_Ht = arma::expmat(-H_regime * ti);\n      \n      // Mean evolution: X(t) = exp(-Ht) * X(0) + (I - exp(-Ht)) * theta\n      omega.col(i) = (I - exp_Ht) * theta_regime;\n      \n      // Variance evolution with EB scaling\n      mat V_integral = arma::inv(H_regime + H_regime.t()) * (I - arma::expmat(-(H_regime + H_regime.t()) * ti));\n      \n      Phi.slice(i) = exp_Ht;\n      V.slice(i) = Sigma_regime * V_integral;\n    }\n    \n    if(i < this->ref_tree_.num_tips()) {\n      V.slice(i) += Sigmae.slice(ri);\n    }\n  }\n};\n\nclass EHD: public QuadraticPoly<EHDTreeType> {\npublic:\n  typedef EHDTreeType TreeType;\n  typedef QuadraticPoly<TreeType> BaseType;\n  typedef EHD MyType;\n  typedef arma::vec StateType;\n  typedef NumericTraitData<TreeType::NodeType> DataType;\n  typedef std::vector<double> ParameterType;\n  typedef SPLITT::PostOrderTraversal<MyType> AlgorithmType;\n\n  CondGaussianEHD<TreeType, DataType> cond_dist_;\n  \n  EHD(TreeType const& tree, DataType const& input_data):\n    BaseType(tree, input_data), cond_dist_(tree, input_data) {\n    \n    BaseType::ptr_cond_dist_.push_back(&cond_dist_);\n  }\n  \n  void SetParameter(ParameterType const& par) {\n    cond_dist_.SetParameter(par, 0);\n  }\n};\n\ntypedef TraversalTaskWrapper<EHD> QuadraticPolyEHD;\n}\n\n#endif // QuadraticPoly_EHD_H_